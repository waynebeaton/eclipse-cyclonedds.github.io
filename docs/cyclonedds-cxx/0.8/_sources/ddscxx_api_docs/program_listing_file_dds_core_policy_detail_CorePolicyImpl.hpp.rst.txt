
.. _program_listing_file_dds_core_policy_detail_CorePolicyImpl.hpp:

Program Listing for File CorePolicyImpl.hpp
===========================================

|exhale_lsh| :ref:`Return to documentation for file <file_dds_core_policy_detail_CorePolicyImpl.hpp>` (``dds/core/policy/detail/CorePolicyImpl.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright(c) 2006 to 2020 ADLINK Technology Limited and others
    *
    * This program and the accompanying materials are made available under the
    * terms of the Eclipse Public License v. 2.0 which is available at
    * http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
    * v. 1.0 which is available at
    * http://www.eclipse.org/org/documents/edl-v10.php.
    *
    * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
    */
   #ifndef CYCLONEDDS_DDS_CORE_POLICY_TCOREPOLICY_IMPL_HPP_
   #define CYCLONEDDS_DDS_CORE_POLICY_TCOREPOLICY_IMPL_HPP_
   
   /*
    * OMG PSM class declaration
    */
   #include <dds/core/policy/CorePolicy.hpp>
   #include <org/eclipse/cyclonedds/core/ReportUtils.hpp>
   
   // Implementation
   
   namespace dds
   {
   namespace core
   {
   namespace policy
   {
   
   //UserData
   
   
   UserData::UserData() : dds::core::Value() { }
   
   
   UserData::UserData(const dds::core::ByteSeq& sequence) : dds::core::Value(sequence) { }
   
   UserData::UserData(const uint8_t* value_begin, const uint8_t* value_end)
   {
       (void)value_begin;
       (void)value_end;
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
   }
   
   
   UserData::UserData(const UserData& other) : dds::core::Value(other.delegate()) { }
   
   
   UserData& UserData::value(const dds::core::ByteSeq& sequence)
   {
       this->delegate().value(sequence);
       return *this;
   }
   
   template <typename OCTET_ITER>
   UserData& UserData::value(OCTET_ITER begin, OCTET_ITER end)
   {
       (void)begin;
       (void)end;
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
       return *this;
   }
   
   
   const dds::core::ByteSeq UserData::value() const
   {
       return this->delegate().value();
   }
   
   const uint8_t* UserData::begin() const
   {
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
       return NULL;
   }
   
   const uint8_t* UserData::end() const
   {
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
       return NULL;
   }
   
   //GroupData
   
   
   GroupData::GroupData() : dds::core::Value() { }
   
   
   GroupData::GroupData(const dds::core::ByteSeq& sequence) : dds::core::Value(sequence) { }
   
   
   GroupData::GroupData(const GroupData& other) : dds::core::Value(other.delegate()) { }
   
   
   GroupData::GroupData(const uint8_t* value_begin, const uint8_t* value_end)
   {
       (void)value_begin;
       (void)value_end;
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
   }
   
   
   GroupData& GroupData::value(const dds::core::ByteSeq& sequence)
   {
       this->delegate().value(sequence);
       return *this;
   }
   
   template <typename OCTET_ITER>
   GroupData& GroupData::value(OCTET_ITER begin, OCTET_ITER end)
   {
       (void)begin;
       (void)end;
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
       return *this;
   }
   
   
   const dds::core::ByteSeq GroupData::value() const
   {
       return this->delegate().value();
   }
   
   const uint8_t* GroupData::begin() const
   {
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
       return NULL;
   }
   
   const uint8_t* GroupData::end() const
   {
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
       return NULL;
   }
   
   //TopicData
   
   
   TopicData::TopicData() : dds::core::Value() { }
   
   
   TopicData::TopicData(const dds::core::ByteSeq& sequence) : dds::core::Value(sequence) { }
   
   
   TopicData::TopicData(const TopicData& other) : dds::core::Value(other.delegate()) { }
   
   TopicData::TopicData(const uint8_t* value_begin, const uint8_t* value_end)
   {
       (void)value_begin;
       (void)value_end;
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
   }
   
   
   TopicData& TopicData::value(const dds::core::ByteSeq& sequence)
   {
       this->delegate().value(sequence);
       return *this;
   }
   
   template <typename OCTET_ITER>
   TopicData& TopicData::value(OCTET_ITER begin, OCTET_ITER end)
   {
       (void)begin;
       (void)end;
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
       return *this;
   }
   
   
   const dds::core::ByteSeq TopicData::value() const
   {
       return this->delegate().value();
   }
   
   const uint8_t* TopicData::begin() const
   {
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
       return NULL;
   }
   
   const uint8_t* TopicData::end() const
   {
       ISOCPP_THROW_EXCEPTION(ISOCPP_ERROR, "Function not currently supported");
       return NULL;
   }
   
   //EntityFactory
   
   
   EntityFactory::EntityFactory(bool autoenable_created_entities) : dds::core::Value(autoenable_created_entities) { }
   
   
   EntityFactory::EntityFactory(const EntityFactory& other) : dds::core::Value(other.delegate()) { }
   
   
   EntityFactory& EntityFactory::autoenable_created_entities(bool autoenable_created_entities)
   {
       this->delegate().auto_enable(autoenable_created_entities);
       return *this;
   }
   
   
   bool EntityFactory::autoenable_created_entities() const
   {
       return this->delegate().auto_enable();
   }
   
   
   EntityFactory EntityFactory::AutoEnable()
   {
       return EntityFactory(true);
   }
   
   
   EntityFactory EntityFactory::ManuallyEnable()
   {
       return EntityFactory(false);
   }
   
   //TransportPriority
   
   
   TransportPriority::TransportPriority(int32_t priority) : dds::core::Value(priority) { }
   
   
   TransportPriority::TransportPriority(const TransportPriority& other) : dds::core::Value(other.delegate()) { }
   
   
   TransportPriority& TransportPriority::value(int32_t priority)
   {
       this->delegate().value(priority);
       return *this;
   }
   
   
   int32_t TransportPriority::value() const
   {
       return this->delegate().value();
   }
   
   //TLifeSpan
   
   
   Lifespan::Lifespan(const dds::core::Duration& duration) : dds::core::Value(duration) { }
   
   
   Lifespan::Lifespan(const Lifespan& other) : dds::core::Value(other.delegate()) { }
   
   
   Lifespan& Lifespan::duration(const dds::core::Duration& duration)
   {
       this->delegate().duration(duration);
       return *this;
   }
   
   
   const dds::core::Duration Lifespan::duration() const
   {
       return this->delegate().duration();
   }
   
   //Deadline
   
   
   Deadline::Deadline(const dds::core::Duration& period) : dds::core::Value(period) { }
   
   
   Deadline::Deadline(const Deadline& other) : dds::core::Value(other.delegate()) { }
   
   
   Deadline& Deadline::period(const dds::core::Duration& period)
   {
       this->delegate().period(period);
       return *this;
   }
   
   
   const dds::core::Duration Deadline::period() const
   {
       return this->delegate().period();
   }
   
   //LatencyBudget
   
   
   LatencyBudget::LatencyBudget(const dds::core::Duration& duration) : dds::core::Value(duration) { }
   
   
   LatencyBudget::LatencyBudget(const LatencyBudget& other) : dds::core::Value(other.delegate()) { }
   
   
   LatencyBudget& LatencyBudget::duration(const dds::core::Duration& duration)
   {
       this->delegate().duration(duration);
       return *this;
   }
   
   
   const dds::core::Duration LatencyBudget::duration() const
   {
       return this->delegate().duration();
   }
   
   //TimeBasedFilter
   
   TimeBasedFilter::TimeBasedFilter(const dds::core::Duration& minimum_separation) : dds::core::Value(minimum_separation) { }
   
   
   TimeBasedFilter::TimeBasedFilter(const TimeBasedFilter& other) : dds::core::Value(other.delegate()) { }
   
   
   TimeBasedFilter& TimeBasedFilter::minimum_separation(const dds::core::Duration& minimum_separation)
   {
       this->delegate().min_separation(minimum_separation);
       return *this;
   }
   
   
   const dds::core::Duration TimeBasedFilter::minimum_separation() const
   {
       return this->delegate().min_separation();
   }
   
   //Partition
   
   
   Partition::Partition(const std::string& name) : dds::core::Value(name)
   {
   
   }
   
   
   Partition::Partition(const dds::core::StringSeq& names) : dds::core::Value(names)
   {
   
   }
   
   
   Partition::Partition(const Partition& other) : dds::core::Value(other.delegate())
   {
   
   }
   
   
   Partition&
   Partition::name(const std::string& name)
   {
       this->delegate().name(name);
       return *this;
   }
   
   
   Partition&
   Partition::name(const dds::core::StringSeq& names)
   {
       this->delegate().name(names);
       return *this;
   }
   
   
   const dds::core::StringSeq
   Partition::name() const
   {
       return this->delegate().name();
   }
   
   #ifdef OMG_DDS_OWNERSHIP_SUPPORT
   
   //Ownership
   
   
   Ownership::Ownership(dds::core::policy::OwnershipKind::Type kind) : dds::core::Value(kind) { }
   
   
   Ownership::Ownership(const Ownership& other) : dds::core::Value(other.delegate()) { }
   
   
   Ownership& Ownership::kind(dds::core::policy::OwnershipKind::Type kind)
   {
       this->delegate().kind(kind);
       return *this;
   }
   
   
   dds::core::policy::OwnershipKind::Type Ownership::kind() const
   {
       return this->delegate().kind();
   }
   
   
   Ownership Ownership::Exclusive()
   {
       return Ownership(dds::core::policy::OwnershipKind::EXCLUSIVE);
   }
   
   
   Ownership Ownership::Shared()
   {
       return Ownership(dds::core::policy::OwnershipKind::SHARED);
   }
   
   //OwnershipStrength
   
   OwnershipStrength::OwnershipStrength(int32_t strength) : dds::core::Value(strength) { }
   
   
   OwnershipStrength::OwnershipStrength(const OwnershipStrength& other) : dds::core::Value(other.delegate()) { }
   
   
   int32_t OwnershipStrength::value() const
   {
       return this->delegate().strength();
   }
   
   
   OwnershipStrength& OwnershipStrength::value(int32_t strength)
   {
       this->delegate().strength(strength);
       return *this;
   }
   
   #endif  // OMG_DDS_OWNERSHIP_SUPPORT
   
   //TWriterDataLifeCycle
   
   WriterDataLifecycle::WriterDataLifecycle(bool autodispose_unregistered_instances) : dds::core::Value(autodispose_unregistered_instances) { }
   
   
   WriterDataLifecycle::WriterDataLifecycle(const WriterDataLifecycle& other) : dds::core::Value(other.delegate()) { }
   
   
   bool WriterDataLifecycle::autodispose_unregistered_instances() const
   {
       return this->delegate().autodispose();
   }
   
   
   WriterDataLifecycle& WriterDataLifecycle::autodispose_unregistered_instances(bool autodispose_unregistered_instances)
   {
       this->delegate().autodispose(autodispose_unregistered_instances);
       return *this;
   }
   
   
   WriterDataLifecycle WriterDataLifecycle::AutoDisposeUnregisteredInstances()
   {
       return WriterDataLifecycle(true);
   }
   
   
   WriterDataLifecycle WriterDataLifecycle::ManuallyDisposeUnregisteredInstances()
   {
       return WriterDataLifecycle(false);
   }
   
   //ReaderDataLifecycle
   
   ReaderDataLifecycle::ReaderDataLifecycle(const dds::core::Duration& autopurge_nowriter_samples_delay, const dds::core::Duration& autopurge_disposed_samples_delay)
       : dds::core::Value(autopurge_nowriter_samples_delay, autopurge_disposed_samples_delay) { }
   
   
   ReaderDataLifecycle::ReaderDataLifecycle(const ReaderDataLifecycle& other)
       : dds::core::Value(other.delegate()) { }
   
   
   const dds::core::Duration ReaderDataLifecycle::autopurge_nowriter_samples_delay() const
   {
       return this->delegate().autopurge_nowriter_samples_delay();
   }
   
   
   ReaderDataLifecycle& ReaderDataLifecycle::autopurge_nowriter_samples_delay(const dds::core::Duration& autopurge_nowriter_samples_delay)
   {
       this->delegate().autopurge_nowriter_samples_delay(autopurge_nowriter_samples_delay);
       return *this;
   }
   
   
   const dds::core::Duration ReaderDataLifecycle::autopurge_disposed_samples_delay() const
   {
       return this->delegate().autopurge_disposed_samples_delay();
   }
   
   
   ReaderDataLifecycle& ReaderDataLifecycle::autopurge_disposed_samples_delay(const dds::core::Duration& autopurge_disposed_samples_delay)
   {
       this->delegate().autopurge_disposed_samples_delay(autopurge_disposed_samples_delay);
       return *this;
   }
   
   
   ReaderDataLifecycle ReaderDataLifecycle::NoAutoPurgeDisposedSamples()
   {
       return ReaderDataLifecycle();
   }
   
   
   ReaderDataLifecycle ReaderDataLifecycle::AutoPurgeDisposedSamples(const dds::core::Duration& autopurge_disposed_samples_delay)
   {
       return ReaderDataLifecycle().autopurge_disposed_samples_delay(autopurge_disposed_samples_delay);
   }
   
   //Durability
   
   
   Durability::Durability(dds::core::policy::DurabilityKind::Type kind) : dds::core::Value(kind) { }
   
   
   Durability::Durability(const Durability& other) : dds::core::Value(other.delegate()) { }
   
   
   Durability& Durability::kind(dds::core::policy::DurabilityKind::Type kind)
   {
       this->delegate().kind(kind);
       return *this;
   }
   
   
   dds::core::policy::DurabilityKind::Type Durability::kind() const
   {
       return this->delegate().kind();
   }
   
   
   Durability Durability::Volatile()
   {
       return Durability(dds::core::policy::DurabilityKind::VOLATILE);
   }
   
   
   Durability Durability::TransientLocal()
   {
       return Durability(dds::core::policy::DurabilityKind::TRANSIENT_LOCAL);
   }
   
   
   Durability Durability::Transient()
   {
       return Durability(dds::core::policy::DurabilityKind::TRANSIENT);
   }
   
   
   Durability Durability::Persistent()
   {
       return Durability(dds::core::policy::DurabilityKind::PERSISTENT);
   }
   
   //Presentation
   
   Presentation::Presentation(dds::core::policy::PresentationAccessScopeKind::Type access_scope, bool coherent_access, bool ordered_access)
       : dds::core::Value(access_scope, coherent_access, ordered_access) { }
   
   
   Presentation::Presentation(const Presentation& other)
       : dds::core::Value(other.delegate()) { }
   
   
   Presentation& Presentation::access_scope(dds::core::policy::PresentationAccessScopeKind::Type access_scope)
   {
       this->delegate().access_scope(access_scope);
       return *this;
   }
   
   
   dds::core::policy::PresentationAccessScopeKind::Type Presentation::access_scope() const
   {
       return this->delegate().access_scope();
   }
   
   
   Presentation& Presentation::coherent_access(bool coherent_access)
   {
       this->delegate().coherent_access(coherent_access);
       return *this;
   }
   
   
   bool Presentation::coherent_access() const
   {
       return this->delegate().coherent_access();
   }
   
   
   Presentation& Presentation::ordered_access(bool ordered_access)
   {
       this->delegate().ordered_access(ordered_access);
       return *this;
   }
   
   
   bool Presentation::ordered_access() const
   {
       return this->delegate().ordered_access();
   }
   
   
   Presentation Presentation::GroupAccessScope(bool coherent_access, bool ordered_access)
   {
       return Presentation(dds::core::policy::PresentationAccessScopeKind::GROUP, coherent_access, ordered_access);
   }
   
   
   Presentation Presentation::InstanceAccessScope(bool coherent_access, bool ordered_access)
   {
       return Presentation(dds::core::policy::PresentationAccessScopeKind::INSTANCE, coherent_access, ordered_access);
   }
   
   
   Presentation Presentation::TopicAccessScope(bool coherent_access, bool ordered_access)
   {
       return Presentation(dds::core::policy::PresentationAccessScopeKind::TOPIC, coherent_access, ordered_access);
   }
   
   //Reliability
   
   Reliability::Reliability(dds::core::policy::ReliabilityKind::Type kind, const dds::core::Duration& max_blocking_time)
       :  dds::core::Value(kind, max_blocking_time) { }
   
   
   Reliability::Reliability(const Reliability& other)
       : dds::core::Value(other.delegate()) { }
   
   
   Reliability& Reliability::kind(dds::core::policy::ReliabilityKind::Type kind)
   {
       this->delegate().kind(kind);
       return *this;
   }
   
   
   dds::core::policy::ReliabilityKind::Type Reliability::kind() const
   {
       return this->delegate().kind();
   }
   
   
   Reliability& Reliability::max_blocking_time(const dds::core::Duration& max_blocking_time)
   {
       this->delegate().max_blocking_time(max_blocking_time);
       return *this;
   }
   
   
   const dds::core::Duration Reliability::max_blocking_time() const
   {
       return this->delegate().max_blocking_time();
   }
   
   
   Reliability Reliability::Reliable(const dds::core::Duration& max_blocking_time)
   {
       return Reliability(dds::core::policy::ReliabilityKind::RELIABLE, max_blocking_time);
   }
   
   
   Reliability Reliability::BestEffort(const dds::core::Duration& max_blocking_time)
   {
       return Reliability(dds::core::policy::ReliabilityKind::BEST_EFFORT, max_blocking_time);
   }
   
   //DestinationOrder
   
   
   DestinationOrder::DestinationOrder(dds::core::policy::DestinationOrderKind::Type kind)
       : dds::core::Value(kind) { }
   
   
   DestinationOrder::DestinationOrder(const DestinationOrder& other) : dds::core::Value(other.delegate()) { }
   
   
   DestinationOrder& DestinationOrder::kind(dds::core::policy::DestinationOrderKind::Type kind)
   {
       this->delegate().kind(kind);
       return *this;
   }
   
   
   dds::core::policy::DestinationOrderKind::Type DestinationOrder::kind() const
   {
       return this->delegate().kind();
   }
   
   
   DestinationOrder DestinationOrder::SourceTimestamp()
   {
       return DestinationOrder(dds::core::policy::DestinationOrderKind::BY_SOURCE_TIMESTAMP);
   }
   
   
   DestinationOrder DestinationOrder::ReceptionTimestamp()
   {
       return DestinationOrder(dds::core::policy::DestinationOrderKind::BY_RECEPTION_TIMESTAMP);
   }
   
   //History
   
   History::History(dds::core::policy::HistoryKind::Type kind, int32_t depth)
       : dds::core::Value(kind, depth) { }
   
   
   History::History(const History& other) : dds::core::Value(other.delegate()) { }
   
   
   dds::core::policy::HistoryKind::Type History::kind() const
   {
       return this->delegate().kind();
   }
   
   
   History& History::kind(dds::core::policy::HistoryKind::Type kind)
   {
       this->delegate().kind(kind);
       return *this;
   }
   
   
   int32_t History::depth() const
   {
       return this->delegate().depth();
   }
   
   
   History& History::depth(int32_t depth)
   {
       this->delegate().depth(depth);
       return *this;
   }
   
   
   History History::KeepAll()
   {
       return History(dds::core::policy::HistoryKind::KEEP_ALL, 1);
   }
   
   
   History History::KeepLast(uint32_t depth)
   {
       return History(dds::core::policy::HistoryKind::KEEP_LAST,
                       static_cast<int32_t>(depth));
   }
   
   //ResourceLimits
   
   ResourceLimits::ResourceLimits(int32_t max_samples, int32_t max_instances, int32_t max_samples_per_instance)
       :  dds::core::Value(max_samples, max_instances, max_samples_per_instance) { }
   
   
   ResourceLimits::ResourceLimits(const ResourceLimits& other)
       : dds::core::Value(other.delegate()) { }
   
   
   ResourceLimits& ResourceLimits::max_samples(int32_t max_samples)
   {
       this->delegate().max_samples(max_samples);
       return *this;
   }
   
   
   int32_t ResourceLimits::max_samples() const
   {
       return this->delegate().max_samples();
   }
   
   
   ResourceLimits& ResourceLimits::max_instances(int32_t max_instances)
   {
       this->delegate().max_instances(max_instances);
       return *this;
   }
   
   
   int32_t ResourceLimits::max_instances() const
   {
       return this->delegate().max_instances();
   }
   
   
   ResourceLimits& ResourceLimits::max_samples_per_instance(int32_t max_samples_per_instance)
   {
       this->delegate().max_samples_per_instance(max_samples_per_instance);
       return *this;
   }
   
   
   int32_t ResourceLimits::max_samples_per_instance() const
   {
       return this->delegate().max_samples_per_instance();
   }
   
   //Liveliness
   
   Liveliness::Liveliness(dds::core::policy::LivelinessKind::Type kind, const dds::core::Duration& lease_duration)
       : dds::core::Value(kind, lease_duration) { }
   
   
   Liveliness::Liveliness(const Liveliness& other) : dds::core::Value(other.delegate()) { }
   
   
   Liveliness& Liveliness::kind(dds::core::policy::LivelinessKind::Type kind)
   {
       this->delegate().kind(kind);
       return *this;
   }
   
   
   dds::core::policy::LivelinessKind::Type Liveliness::kind() const
   {
       return this->delegate().kind();
   }
   
   
   Liveliness& Liveliness::lease_duration(const dds::core::Duration& lease_duration)
   {
       this->delegate().lease_duration(lease_duration);
       return *this;
   }
   
   
   const dds::core::Duration Liveliness::lease_duration() const
   {
       return this->delegate().lease_duration();
   }
   
   
   Liveliness Liveliness::Automatic(const dds::core::Duration& lease_duration)
   {
       return Liveliness(dds::core::policy::LivelinessKind::AUTOMATIC, lease_duration);
   }
   
   
   Liveliness Liveliness::ManualByParticipant(const dds::core::Duration& lease_duration)
   {
       return Liveliness(dds::core::policy::LivelinessKind::MANUAL_BY_PARTICIPANT, lease_duration);
   }
   
   
   Liveliness Liveliness::ManualByTopic(const dds::core::Duration& lease_duration)
   {
       return Liveliness(dds::core::policy::LivelinessKind::MANUAL_BY_TOPIC, lease_duration);
   }
   
   
   #ifdef OMG_DDS_PERSISTENCE_SUPPORT
   
   //DurabilityService
   
   
   DurabilityService::DurabilityService(
       const dds::core::Duration& service_cleanup_delay,
       dds::core::policy::HistoryKind::Type history_kind,
       int32_t history_depth,
       int32_t max_samples,
       int32_t max_instances,
       int32_t max_samples_per_instance)
       : dds::core::Value(service_cleanup_delay,
                             history_kind,
                             history_depth,
                             max_samples,
                             max_instances,
                             max_samples_per_instance) { }
   
   
   DurabilityService::DurabilityService(const DurabilityService& other)
       : dds::core::Value(other.delegate()) { }
   
   
   DurabilityService& DurabilityService::service_cleanup_delay(const dds::core::Duration& service_cleanup_delay)
   {
       this->delegate().service_cleanup_delay(service_cleanup_delay);
       return *this;
   }
   
   
   const dds::core::Duration DurabilityService::service_cleanup_delay() const
   {
       return this->delegate().service_cleanup_delay();
   }
   
   
   DurabilityService& DurabilityService::history_kind(dds::core::policy::HistoryKind::Type kind)
   {
       this->delegate().history_kind(kind);
       return *this;
   }
   
   
   dds::core::policy::HistoryKind::Type DurabilityService::history_kind() const
   {
       return this->delegate().history_kind();
   }
   
   
   DurabilityService& DurabilityService::history_depth(int32_t history_depth)
   {
       this->delegate().history_depth(history_depth);
       return *this;
   }
   
   
   int32_t DurabilityService::history_depth() const
   {
       return this->delegate().history_depth();
   }
   
   
   DurabilityService& DurabilityService::max_samples(int32_t max_samples)
   {
       this->delegate().max_samples(max_samples);
       return *this;
   }
   
   
   int32_t DurabilityService::max_samples() const
   {
       return this->delegate().max_samples();
   }
   
   
   DurabilityService& DurabilityService::max_instances(int32_t max_instances)
   {
       this->delegate().max_instances(max_instances);
       return *this;
   }
   
   
   int32_t DurabilityService::max_instances() const
   {
       return this->delegate().max_instances();
   }
   
   
   DurabilityService& DurabilityService::max_samples_per_instance(int32_t max_samples_per_instance)
   {
       this->delegate().max_samples_per_instance(max_samples_per_instance);
       return *this;
   }
   
   
   int32_t DurabilityService::max_samples_per_instance() const
   {
       return this->delegate().max_samples_per_instance();
   }
   
   #endif  // OMG_DDS_PERSISTENCE_SUPPORT
   
   
   #ifdef OMG_DDS_EXTENSIBLE_AND_DYNAMIC_TOPIC_TYPE_SUPPORT
   
   //DataRepresentation
   
   DataRepresentation::DataRepresentation(const dds::core::policy::DataRepresentationIdSeq& value);
   
   
   DataRepresentation::DataRepresentation(const DataRepresentation& other) : dds::core::Value(other.delegate()) { }
   
   DataRepresentation& DataRepresentation::value(const dds::core::policy::DataRepresentationIdSeq& value);
   
   const dds::core::policy::DataRepresentationIdSeq DataRepresentation::value() const;
   
   #endif  // defined(OMG_DDS_EXTENSIBLE_AND_DYNAMIC_TOPIC_TYPE_SUPPORT)
   
   #ifdef OMG_DDS_EXTENSIBLE_AND_DYNAMIC_TOPIC_TYPE_SUPPORT
   
   //TypeConsistencyEnforcement
   
   TypeConsistencyEnforcement::TypeConsistencyEnforcement(dds::core::policy::TypeConsistencyEnforcementKind::Type kind) { }
   
   TypeConsistencyEnforcement& TypeConsistencyEnforcement::kind(dds::core::policy::TypeConsistencyEnforcementKind::Typekind) { }
   
   dds::core::policy::TypeConsistencyEnforcementKind::Type TypeConsistencyEnforcement::kind() const { }
   
   #endif  // defined(OMG_DDS_EXTENSIBLE_AND_DYNAMIC_TOPIC_TYPE_SUPPORT)
   
   }
   }
   }
   
   // End of implementation
   // OMG PSM class declaration
   
   #endif /* CYCLONEDDS_DDS_CORE_POLICY_TCOREPOLICY_IMPL_HPP_ */
   // OMG PSM class declaration
