
.. _program_listing_file_dds_core_detail_ReferenceImpl.hpp:

Program Listing for File ReferenceImpl.hpp
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file_dds_core_detail_ReferenceImpl.hpp>` (``dds/core/detail/ReferenceImpl.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * Copyright(c) 2006 to 2020 ADLINK Technology Limited and others
    *
    * This program and the accompanying materials are made available under the
    * terms of the Eclipse Public License v. 2.0 which is available at
    * http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
    * v. 1.0 which is available at
    * http://www.eclipse.org/org/documents/edl-v10.php.
    *
    * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
    */
   #ifndef CYCLONEDDS_DDS_CORE_REFERENCE_IMPL_HPP_
   #define CYCLONEDDS_DDS_CORE_REFERENCE_IMPL_HPP_
   
   /*
    * OMG PSM class declaration
    */
   #include <dds/core/Reference.hpp>
   #include <org/eclipse/cyclonedds/core/ReportUtils.hpp>
   
   // Implementation
   
   dds::core::Reference::Reference(dds::core::null_type&) : impl_()
   {
   }
   
   
   dds::core::Reference::Reference(const Reference& ref) : impl_(ref.impl_)
   {
   }
   
   
   dds::core::Reference::Reference(Reference&& ref) : impl_(ref.impl_)
   {
   }
   
   
   
   dds::core::Reference::Reference(const Reference& ref)
   {
       impl_ = ::std::dynamic_pointer_cast<DELEGATE_T>(ref.impl_);
       if (impl_ != ref.impl_) {
           throw dds::core::IllegalOperationError(std::string("Attempted invalid cast: ") + typeid(ref).name() + " to " + typeid(*this).name());
       }
   }
   
   
   dds::core::Reference::Reference(DELEGATE_T* p) : impl_(p)
   {
   }
   
   
   dds::core::Reference::Reference(const DELEGATE_REF_T& p) : impl_(p)
   {
       //OMG_DDS_LOG("MM", "Reference(DELEGATE_REF_T& p)");
   }
   
   
   dds::core::Reference::~Reference()
   {
   }
   
   
   dds::core::Reference::operator DELEGATE_REF_T() const
   {
       ISOCPP_BOOL_CHECK_AND_THROW(impl_, ISOCPP_NULL_REFERENCE_ERROR, "Reference[%d] == dds::core::null", __LINE__);
       return impl_;
   }
   
   
   template <typename R>
   bool
   dds::core::Reference::operator==(const R& ref) const
   {
       bool equal = false;
       if (this->is_nil() && ref.is_nil()) {
           /* Both delegates are null. */
           equal = true;
       } else if (!this->is_nil() && !ref.is_nil()) {
           /* Check delegates. */
           equal = (this->delegate() == ref.delegate());
       }
       return equal;
   }
   
   
   template <typename R>
   bool
   dds::core::Reference::operator!=(const R& ref) const
   {
       return !(*this == ref);
   }
   
   
   
   dds::core::Reference&
   dds::core::Reference::operator=(const Reference& that)
   {
       OMG_DDS_STATIC_ASSERT((dds::core::is_base_of<DELEGATE_T, D>::value));
       if(this != static_cast<Reference*>(&that))
       {
           *this = Reference<DELEGATE_T>(that);
       }
       return *this;
   }
   
   
   template <typename R>
   dds::core::Reference&
   dds::core::Reference::operator=(const R& rhs)
   {
       OMG_DDS_STATIC_ASSERT((dds::core::is_base_of< DELEGATE_T, typename R::DELEGATE_T>::value));
       if(this != static_cast<Reference*>(&rhs))
       {
           *this = Reference<DELEGATE_T>(rhs);
       }
       return *this;
   }
   
   
   dds::core::Reference&
   dds::core::Reference::operator=(const null_type)
   {
       DELEGATE_REF_T tmp;
       impl_ = tmp;
       return *this;
   }
   
   
   bool
   dds::core::Reference::is_nil() const
   {
       return impl_.get() == 0;
   }
   
   
   bool
   dds::core::Reference::operator==(const null_type) const
   {
       return this->is_nil();
   }
   
   
   bool
   dds::core::Reference::operator!=(const null_type) const
   {
       return !(this->is_nil());
   }
   
   
   const typename dds::core::Reference::DELEGATE_REF_T&
   dds::core::Reference::delegate() const
   {
       ISOCPP_BOOL_CHECK_AND_THROW(impl_, ISOCPP_NULL_REFERENCE_ERROR, "Reference[%d] == dds::core::null", __LINE__);
       return impl_;
   }
   
   
   typename dds::core::Reference::DELEGATE_REF_T&
   dds::core::Reference::delegate()
   {
       ISOCPP_BOOL_CHECK_AND_THROW(impl_, ISOCPP_NULL_REFERENCE_ERROR, "Reference[%d] == dds::core::null", __LINE__);
       return impl_;
   }
   
   
   DELEGATE*
   dds::core::Reference::operator->()
   {
       ISOCPP_BOOL_CHECK_AND_THROW(impl_, ISOCPP_NULL_REFERENCE_ERROR, "Reference[%d] == dds::core::null", __LINE__);
       return impl_.get();
   }
   
   
   const DELEGATE*
   dds::core::Reference::operator->() const
   {
       ISOCPP_BOOL_CHECK_AND_THROW(impl_, ISOCPP_NULL_REFERENCE_ERROR, "Reference[%d] == dds::core::null", __LINE__);
       return impl_.get();
   }
   
   
   dds::core::Reference::operator
   const typename dds::core::Reference::DELEGATE_REF_T& () const
   {
       ISOCPP_BOOL_CHECK_AND_THROW(impl_, ISOCPP_NULL_REFERENCE_ERROR, "Reference[%d] == dds::core::null", __LINE__);
       return impl_;
   }
   
   
   dds::core::Reference::operator
   typename dds::core::Reference::DELEGATE_REF_T& ()
   {
       ISOCPP_BOOL_CHECK_AND_THROW(impl_, ISOCPP_NULL_REFERENCE_ERROR, "Reference[%d] == dds::core::null", __LINE__);
       return impl_;
   }
   
   
   void dds::core::Reference::set_ref(DELEGATE_T* p)
   {
       impl_.reset(p);
   }
   
   
   template <class D> bool operator == (dds::core::null_type, const dds::core::Reference& r)
   {
       return r.is_nil();
   }
   
   template <class D> bool operator != (dds::core::null_type, const dds::core::Reference& r)
   {
       return !r.is_nil();
   }
   
   // End of implementation
   
   #endif /* CYCLONEDDS_DDS_CORE_REFERENCE_IMPL_HPP_ */
